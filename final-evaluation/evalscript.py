import os
import sys
import re
# Force matplotlib to not use any Xwindows backend.
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from matplotlib_venn import venn3
import pandas as pd
import multiprocessing as mp

# for a target, find unique violations that were only covered by 1 fuzzer
# for each (fuzzer,target) -> store violations
violations_dict = {}
violations_dict_with_msg = {}
violations_dict_with_msg_lists = {}
all_targets = set()
all_seeds = set()
def get_data_full(path, fuzzer_name=None):
  res = {}

  # get all results
  for _, _, filename in os.walk(path):
    pass

  # filename contains all files in dir now

  for f in filename:
    # filter out aggreated results
    if not f.startswith('result-'):
      continue

    # print f
    m = re.match(r'result\-(.*?)-(\d+)\.txt', f)
    if not m:
      print('not match for', f)
      break

    target_name = m.group(1)
    all_targets.add(target_name)
    #fuzzer_name = targetname?
    # e.g. lfstandalone contains:
    # --> result-jpeg-123.txt
    # --> result-sqlite-555.txt
    # --> result-png-999.txt
    # all generated by standalone libfuzzer

    seed = m.group(2)
    all_seeds.add(seed)

    tcnum = ''
    cov = ''
    corp = ''
    speed = ''
    crashed = False
    ttt = res.get(target_name, {})
    res[target_name] = ttt
    ttt =[]

    #nUBSAN = 0
    ubsan_violations = set()#[]
    ubsan_violations_with_msg = set()#[]
    ubsan_violations_with_msg_list = []

    with open(path + f, 'r') as fp:
      data = fp.read()
      for d in data.splitlines():
        if 'Test unit written to ./crash-' in d:
          crashed = True
        #geodesic.c:207:11: runtime error: signed integer overflow: 90 * -2147483648 cannot be represented in type 'int'
        m = re.match(r'(.+):(\d+):(\d+): runtime error: (.+): (.*)', d)
        if m:
          ubsan_violations.add((m.group(1), m.group(2), m.group(3), m.group(4)))#, m.group(5)])
          ubsan_violations_with_msg.add((m.group(1), m.group(2), m.group(3), m.group(4), m.group(5)))
          ubsan_violations_with_msg_list.append((m.group(1), m.group(2), m.group(3), m.group(4), m.group(5)))
          #nUBSAN += 1
        
        #m = re.match(r'#(\d+).+?cov: (\d+).+? corp: (\d+)/.+?exec/s: (\d+).*?', d)
        m = re.match(r'#(\d+).+?cov: (\d+).+? corp: (\d+)/.+?exec/s: (\d+) time: (\d+).*?', d)
        if m:
          # print 'testcase num', m.  (1), 'cov:', m.group(2), 'exec/s', m.group(3)
          tcnum = m.group(1)
          cov = m.group(2)
          corp = m.group(3)
          speed = m.group(4)
          time = m.group(5)
          ttt.append([tcnum, cov, corp, speed, crashed, len(ubsan_violations), time])

    res[target_name][str(seed)] = ttt # no timestamp?
    print('ubsan violations (' + str(len(ubsan_violations)) + ') for ' + fuzzer_name + '-' + target_name + ": " + str(ubsan_violations))
    violations_dict[(target_name, fuzzer_name, seed)] = ubsan_violations#1#set(ubsan_violations)
    violations_dict_with_msg[(target_name, fuzzer_name, seed)] = ubsan_violations_with_msg #1#set(ubsan_violations)
    violations_dict_with_msg_lists[(target_name, fuzzer_name, seed)] = ubsan_violations_with_msg_list #1#set(ubsan_violations)
    print('crashed: ' + str(crashed))
  return res

def get_data_set(df, d1, name, max_time, cov_or_ubsan):
  assert cov_or_ubsan in ['cov', 'ubsan'], "cov_or_ubsan not set."

  for seed, d in d1.items():
    val = [None] * (max_time)

    assert max_time >= int(d[-1][6])
    for data_i in range(0, len(d)):
      data_time = int(d[data_i][6])
      data_cov  = int(d[data_i][1])
      data_ubsan = int(d[data_i][5])

      if cov_or_ubsan == 'ubsan':
        val[data_time] = data_ubsan
      else:
        val[data_time] = data_cov

    cur_cov = 0
    cur_ubsan = 0
    for time_i in range(0, min(len(val), int(d[-1][6]))):
      if val[time_i] != None:
        if cov_or_ubsan == 'ubsan':
          cur_ubsan = val[time_i]
        else:
          cur_cov = val[time_i]

      if cov_or_ubsan == 'ubsan':
        val[time_i] = cur_ubsan
      else:
        val[time_i] = cur_cov

    print('len val = ', len(val), max_time)
    df[name+'-'+str(seed)] = val


plt_ubsan = False
plt_cov = False
def do_plot(args):
  global plt_ubsan
  global plt_cov
  #plt_ubsan=True
  #plt_cov=True
  #standalone_min_line, standalone_max_line, saviororig_min_line, saviororig_max_line, saviorreimpl_min_line, saviorreimpl_max_line)
  target_name, d1, d2, d3, standalone_min_line, standalone_max_line, saviororig_min_line, saviororig_max_line, saviorreimpl_min_line, saviorreimpl_max_line = args
  max_time = 0

  for k, d in d1.items():
    max_time = max(max_time, int(d[-1][6]))

  for k, d in d2.items():
    max_time = max(max_time, int(d[-1][6]))

  for k, d in d3.items():
    max_time = max(max_time, int(d[-1][6]))

  max_time += 1000

  if plt_ubsan:
    print('Plot ubsan ...')
    df=pd.DataFrame({'x': range(0, max_time)})
    
    get_data_set(df, d1, 'standalone', max_time, 'ubsan')
    get_data_set(df, d2, 'saviororig', max_time, 'ubsan')
    get_data_set(df, d3, 'saviorreimpl', max_time, 'ubsan')
    
    plt.style.use('seaborn-darkgrid') #whitegrid') #darkgrid
    #plt.gca().set_facecolor('k')
    palette = plt.get_cmap('Paired')
    num=0
    
    for column in df.drop('x', axis=1):
      if 'standalone' in column:
        #plt.plot(df['x'], df[column], linestyle='-', marker='', color=palette(num), linewidth=1, alpha=0.7, label=column)
        #num += 2
        plt.plot(df['x'], df[column], linestyle='-', marker='', color='r', linewidth=1, alpha=0.9, label=column)
        plt.fill_between(x=range(0, len(standalone_min_line)),y1=standalone_min_line,y2=standalone_max_line, alpha=0.3, color='r')
    for column in df.drop('x', axis=1):
      if 'saviororig' in column:
        #num += 2
        #plt.plot(df['x'], df[column], linestyle='-', marker='', color=palette(num), linewidth=1, alpha=0.7, label=column)
        plt.plot(df['x'], df[column], linestyle='-', marker='', color='orange', linewidth=1, alpha=0.9, label=column)
        plt.fill_between(x=range(0, len(saviororig_min_line)),y1=saviororig_min_line,y2=saviororig_max_line, alpha=0.5, color='orange')
    for column in df.drop('x', axis=1):
      if 'saviorreimpl' in column:
        #num += 2
        #plt.plot(df['x'], df[column], linestyle='-', marker='', color=palette(num), linewidth=1, alpha=0.7, label=column)
        plt.plot(df['x'], df[column], linestyle='-', marker='', color='blue', linewidth=1, alpha=1, label=column)
        plt.fill_between(x=range(0, len(saviorreimpl_min_line)),y1=saviorreimpl_min_line,y2=saviorreimpl_max_line, alpha=0.3, color='blue')
    

    plt.legend(ncol=2, loc='lower right')
    plt.title("UBSAN violations for "+target_name, loc='left', fontsize=12, fontweight=0, color='k')
    plt.xlabel("time (s)")
    plt.ylabel("UBSAN violations")

    plt.savefig('ubsan-'+target_name+'.png', dpi=600)#150)
    print('Saved plot')
    plt.clf()
    plt.close()
    del df

  if plt_cov:
    print('Plot cov ...')
    df=pd.DataFrame({'x': range(0, max_time)})

    get_data_set(df, d1, 'standalone', max_time, 'cov')
    get_data_set(df, d2, 'saviororig', max_time, 'cov')
    get_data_set(df, d3, 'saviorreimpl', max_time, 'cov')

    plt.style.use('seaborn-darkgrid')
    palette = plt.get_cmap('Paired')
    num=0

    for column in df.drop('x', axis=1):
      if 'standalone' in column:
        plt.plot(df['x'], df[column], linestyle='-', marker='', color='r', linewidth=1, alpha=0.9, label=column)
        plt.fill_between(x=range(0, len(standalone_min_line)),y1=standalone_min_line,y2=standalone_max_line, alpha=0.3, color='r')
    for column in df.drop('x', axis=1):
      if 'saviororig' in column:
        plt.plot(df['x'], df[column], linestyle='-', marker='', color='orange', linewidth=1, alpha=0.9, label=column)
        plt.fill_between(x=range(0, len(saviororig_min_line)),y1=saviororig_min_line,y2=saviororig_max_line, alpha=0.5, color='orange')
    for column in df.drop('x', axis=1):
      if 'saviorreimpl' in column:
        plt.plot(df['x'], df[column], linestyle='-', marker='', color='blue', linewidth=1, alpha=1, label=column)
        plt.fill_between(x=range(0, len(saviorreimpl_min_line)),y1=saviorreimpl_min_line,y2=saviorreimpl_max_line, alpha=0.3, color='blue')

    plt.legend(ncol=2, loc='lower right')
    plt.title("cov for "+target_name, loc='left', fontsize=12, fontweight=0, color='k')
    plt.xlabel("time (s)")
    plt.ylabel("cov")

    plt.savefig('cov-'+target_name+'.png', dpi=600)#150)
    plt.clf()
    plt.close()
    del df

def interpolate_ubsan(timestamps, ubsans, maxtime=86400): #1day
  #go through interpolated, set values we know
  #fill in missing values
  interpolated = [0] * maxtime
  for i in range(len(timestamps)):
    if timestamps[i] >= maxtime:
      break

    interpolated[timestamps[i]] = ubsans[i]

  ubsan = 0
  for i in range(len(interpolated)):
    if interpolated[i] > ubsan:
      ubsan = interpolated[i]
    else:
      interpolated[i] = ubsan

  return interpolated


def compute_mean_seed(target, rX, bUBSAN=True):
  interpolated_runs = {}#[]
  runs = rX[target] # 1 run per seed, for now only standalone
  for i, r in enumerate(runs): #r --> seed
    timestamps = []
    ubsans = []
    print("len run {}: {}".format(i, len(runs[r])))
    for k in range(len(runs[r])):
      timestamps.append(int(runs[r][k][-1])) #time
      if bUBSAN:
        ubsans.append(int(runs[r][k][-2])) #ubsan
      else:
        ubsans.append(int(runs[r][k][1])) #cov
    interpolated_run = interpolate_ubsan(timestamps, ubsans)
    #interpolated_runs.append(interpolated_run)
    interpolated_runs[r] = interpolated_run

  votes = {}
  length = -1
  for seed, run in interpolated_runs.items(): #range(len(interpolated_runs)): #make sure all interpolated lists have the same length
    if length==-1:
      length = len(run)
    else:
      assert length == len(run)

  assert length > -1

  #print("interpolated runs: " + str(interpolated_runs))
  min_line = [] #min ubsan violations across all seeds
  max_line = [] #max ubsan violations across all seeds (for shadow)
  for i in range(length):
    cur = []
    for seed, run in interpolated_runs.items():
      cur.append((seed, run[i]))#run[i] = #ubsan?
    #for k in range(len(interpolated_runs)):
    #  cur.append((k, interpolated_runs[k][i])) # add tuple (k=#seed, #ubsan violations)
    sorted_cur = sorted(cur, key=lambda x: x[1])
    #print("sorted_cur: " + str(sorted_cur))
    mean = sorted_cur[len(sorted_cur)//2][0] # mean (seed-#) # This is actually ceil'ing, as index is 0-based. e.g 4 entries//2 -> select index 2 from {0,1,2,3}.
    min_line.append(sorted_cur[0][1]) # lowest # of ubsan violations across all seeds
    max_line.append(sorted_cur[-1][1]) #highest # of ubsan violations
    if mean in votes:
      votes[mean] += 1
    else:
      votes[mean] = 1

  print("votes: " + str(votes))

  maxvotes = -1
  mean_seedno = -1
  for seedno, nvotes in votes.items(): #key:seedno item:nvotes
    if nvotes > maxvotes:
      maxvotes = nvotes
      mean_seedno = seedno
  print("target: " + target + " mean seed no: " + str(mean_seedno))
  print("keys in runs:")
  for thekey in runs:
    print(thekey)
  return (mean_seedno, min_line, max_line)
  #return runs[mean_seedno]

mean_seeds = {}
def main():
  #lfstandalone should contain 3 fuzz.log's of the same experiment(i.e. libFuzzer only [different seeds?]
  lfstandalone = './libFuzzer/'  #'./lfstandalone/'
  lfsaviororig = './libFuzzer-SAVIOR-orig/'   #'./lfsaviororig/'
  lfsaviorreimpl = './libFuzzer-SAVIOR-reimpl/'   #'./lfsaviorreimpl/'

  r1 = get_data_full(lfstandalone, "standalone")
  # r1 contains map target_name -> statistics;;;;;;; r1 corresponds to standalone libfuzzer
  r2 = get_data_full(lfsaviororig, "saviororig")
  r3 = get_data_full(lfsaviorreimpl, "saviorreimpl")

###################
#plot ubsan#######
###################
  args = []
  for target in all_targets:#['lcms-2017-03-21', 'sqlite3']:
    standalone_seednr, standalone_min_line, standalone_max_line = compute_mean_seed(target, r1)
    saviororig_seednr, saviororig_min_line, saviororig_max_line = compute_mean_seed(target, r2)
    saviorreimpl_seednr, saviorreimpl_min_line, saviorreimpl_max_line = compute_mean_seed(target, r3)
    standalone_dict = {}
    saviororig_dict = {}
    saviorreimpl_dict = {}
    standalone_dict[standalone_seednr] = r1[target][standalone_seednr] #mean
    saviororig_dict[saviororig_seednr] = r2[target][saviororig_seednr]
    saviorreimpl_dict[saviorreimpl_seednr] = r3[target][saviorreimpl_seednr]
    args.append((target, standalone_dict, saviororig_dict, saviorreimpl_dict, standalone_min_line, standalone_max_line, saviororig_min_line, saviororig_max_line, saviorreimpl_min_line, saviorreimpl_max_line))

  global plt_ubsan
  global plt_cov
  plt_ubsan = True
  plt_cov = False

  p = mp.Pool(30)
  for _ in p.map(do_plot, args):
    print('. '),
  print('')

##################
#plot cov#########
##################

  args = []
  for target in all_targets:#['lcms-2017-03-21', 'sqlite3']:
    standalone_seednr, standalone_min_line, standalone_max_line = compute_mean_seed(target, r1, False)
    saviororig_seednr, saviororig_min_line, saviororig_max_line = compute_mean_seed(target, r2, False)
    saviorreimpl_seednr, saviorreimpl_min_line, saviorreimpl_max_line = compute_mean_seed(target, r3, False)
    standalone_dict = {}
    saviororig_dict = {}
    saviorreimpl_dict = {}
    standalone_dict[standalone_seednr] = r1[target][standalone_seednr] #mean
    saviororig_dict[saviororig_seednr] = r2[target][saviororig_seednr]
    saviorreimpl_dict[saviorreimpl_seednr] = r3[target][saviorreimpl_seednr]
    args.append((target, standalone_dict, saviororig_dict, saviorreimpl_dict, standalone_min_line, standalone_max_line, saviororig_min_line, saviororig_max_line, saviorreimpl_min_line, saviorreimpl_max_line))

  plt_ubsan = False
  plt_cov = True

  p = mp.Pool(30)
  for _ in p.map(do_plot, args):
    print('. '),
  print('')
##################
#####venn plot####
##################
  for target in all_targets:
    print("---------------------------")
    print("Target: " + target)
    print("---------------------------\n")

    all_violations_standalone = set.union(* [ violations_dict[(target, "standalone", seed)] for seed in all_seeds])
    all_violations_saviororig = set.union(* [ violations_dict[(target, "saviororig", seed)] for seed in all_seeds])
    all_violations_saviorreimpl = set.union(* [ violations_dict[(target, "saviorreimpl", seed)] for seed in all_seeds])

    plt.figure(figsize=(4,4))
    v = venn3([all_violations_standalone, all_violations_saviororig, all_violations_saviorreimpl], ('libFuzzer', 'SAVIOR-orig', 'SAVIOR-reimpl'))
    v.get_label_by_id("A").set_color('red')
    v.get_label_by_id("B").set_color('orange')
    v.get_label_by_id("C").set_color('blue')
    if v.get_patch_by_id('100') is not None:
      v.get_patch_by_id('100').set_color('red')
    if v.get_patch_by_id('010') is not None:
      v.get_patch_by_id('010').set_color('orange')
    if v.get_patch_by_id('001') is not None:
      v.get_patch_by_id('001').set_color('blue')

    #v.get_label_by_id('libFuzzer').set_color('red')
    #v.get_label_by_id('SAVIOR-orig').set_color('green')
    #v.get_label_by_id('SAVIOR-reimpl').set_color('blue')

    #plt.annotate('Unknown set', xy=v.get_label_by_id('100').get_position() - np.array([0, 0.05]), xytext=(-70,-70),
    #ha='center', textcoords='offset points', bbox=dict(boxstyle='round,pad=0.5', fc='gray', alpha=0.1),
    #arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0.5',color='gray'))
    plt.title("UBSAN violations for "+target, loc='center', fontsize=10, fontweight=0, color='black')

    plt.savefig('venn-'+target+'.png', dpi=600)#150)
    print('Saved venn')
    plt.clf()
    plt.close()

if __name__ == '__main__':
  main()

